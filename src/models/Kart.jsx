/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 --shadows ./models/kart.glb 
*/

import React, { useEffect, useRef } from "react";
import { useGLTF, useKeyboardControls } from "@react-three/drei";
import { useFrame, useThree } from "@react-three/fiber";
import { clamp, lerp } from "three/src/math/MathUtils.js";
import VFXEmitter from "../wawa-vfx/VFXEmitter.tsx";
import { getDriftLevel } from "../constants.js";
import { Glow } from "../particles/drift/Glow.jsx";
import { useGameStore } from "../store.js";
import { Raycaster, Vector3, Quaternion } from "three";
import { KartDust } from "./KartDust.jsx";
import { Sparks } from "../particles/sparks/Sparks.jsx";
import { Skate } from "../particles/drift/Skate.jsx";
import { Trails } from "../particles/sparks/Trails.jsx";
const raycaster = new Raycaster();

export function Kart({ speed, driftDirection, driftPower, jumpOffset }) {
  const { nodes, materials } = useGLTF("/models/kart.glb");

  const wheel3 = useRef(null);
  const wheel2 = useRef(null);
  const wheel1 = useRef(null);
  const wheel0 = useRef(null);
  const groupRef = useRef(null);
  const frontWheels = useRef(null);
  const dustWheelStates = useRef([
    { position: new Vector3(), shouldEmit: false },
    { position: new Vector3(), shouldEmit: false },
    { position: new Vector3(), shouldEmit: false },
    { position: new Vector3(), shouldEmit: false },
  ]);

  const bodyRef = useRef(null);
  const dampenedSpeedRef = useRef(0);
  const prevSpeedRef = useRef(0);

  const leftParticles = useRef(null);
  const rightParticles = useRef(null);

  const sparksLeftRef = useRef(null);
  const sparksRightRef = useRef(null);

  const skate1Ref = useRef(null);
  const skate2Ref = useRef(null);

  const glow1Ref = useRef(null);
  const glow2Ref = useRef(null);

  const smoke1Ref = useRef(null);
  const smoke2Ref = useRef(null);

  const [, get] = useKeyboardControls();
  const yRotation = useRef(0);
  const wheelRef = useRef(null);

  const isDriftingRef = useRef(false);

  const flamePositionLeftRef = useRef(null);
  const flamePositionRightRef = useRef(null);

  const setFlamePositions = useGameStore((state) => state.setFlamePositions);
  const setBoostPower = useGameStore((state) => state.setBoostPower);
  const setDriftLevel = useGameStore((state) => state.setDriftLevel);
  const setGroundPosition = useGameStore((state) => state.setGroundPosition);
  const { scene } = useThree();

  function getGroundPosition(wheel) {
    const origin = new Vector3();
    const direction = new Vector3(0, -1, 0);

    wheel.current.getWorldPosition(origin);

    raycaster.set(origin, direction);
    raycaster.far = 2;
    raycaster.firstHitOnly = true;

    const intersects = raycaster.intersectObjects(scene.children, true);

    if (intersects.length > 0) {
      const hit = intersects[0];
      if (hit.object.name.includes("ground")) {
        wheel.current.position.y = hit.point.y + 0.8 + jumpOffset.current;
      }
      wheel.current.isOnDirt =
        (hit.object.name.includes("dirt") && speed.current > 20) && jumpOffset.current === 0;
    }
  }
  useFrame((_, delta) => {
    if (wheel0.current && wheel1.current && wheel2.current && wheel3.current) {
      const isDrifting = !!driftDirection.current && jumpOffset.current === 0;
      const { left, right } = get();
      const rotationSpeed = speed.current * 0.01;
      wheel0.current.rotation.x += rotationSpeed;
      wheel1.current.rotation.x += rotationSpeed;
      wheel2.current.rotation.x += rotationSpeed;
      wheel3.current.rotation.x += rotationSpeed;

      getGroundPosition(wheel0);
      getGroundPosition(wheel1);
      getGroundPosition(wheel2);
      getGroundPosition(wheel3);

      const wheelPositions = [wheel0, wheel1, wheel2, wheel3].map(
        (wheel, index) => {
          const position = wheel.current.getWorldPosition(new Vector3());
          const localPos = wheel.current.position;
          dustWheelStates.current[index].position = localPos;
          dustWheelStates.current[index].shouldEmit = wheel.current.isOnDirt;

          index == 0
            ? leftParticles.current.position.set(
                localPos.x - 0.2,
                localPos.y - .7,
                localPos.z + .2
              )
            : null;
          index == 1
            ? rightParticles.current.position.set(
                localPos.x + .2,
                localPos.y - .7,
                localPos.z + .2
              )
            : null;

          return position;
        }
      );

      const a = wheelPositions[0];
      const b = wheelPositions[1];
      const c = wheelPositions[2];
      const d = wheelPositions[3];

      const currentSpeed = speed.current;
      const prevSpeed = prevSpeedRef.current || currentSpeed;
      const acceleration = (currentSpeed - prevSpeed) / delta;
      prevSpeedRef.current = currentSpeed;

      dampenedSpeedRef.current = lerp(
        dampenedSpeedRef.current,
        acceleration,
        8 * delta
      );

      const pitch = (c.y + d.y - (a.y + b.y)) * 0.5;
      const roll = (b.y - a.y + d.y - c.y) * 0.5;

      const averageYPos = 0.65 + (a.y + b.y + c.y + d.y) / 4;
      setGroundPosition(averageYPos);
      

      bodyRef.current.rotation.x = lerp(
        bodyRef.current.rotation.x,
        pitch,
        8 * delta
      );

      bodyRef.current.rotation.z = lerp(
        bodyRef.current.rotation.z,
        roll,
        8 * delta
      );
      // bodyRef.current.position.y = lerp(
      //   bodyRef.current.position.y,
      //   averageYPos + jumpOffset.current * 0.2,
      //   12 * delta
      // );
      
      bodyRef.current.position.y = averageYPos + jumpOffset.current * 0.1

      yRotation.current = lerp(
        yRotation.current,
        Number(right) - Number(left),
        4 * delta
      );

      frontWheels.current.rotation.y = -yRotation.current * 0.1;
      wheelRef.current.rotation.y = -yRotation.current;

      if (speed.current > 15 ) {
        smoke1Ref.current?.stopEmitting();
        smoke2Ref.current?.stopEmitting();
      } else {
        smoke1Ref.current?.startEmitting();
        smoke2Ref.current?.startEmitting();
      }

      groupRef.current.rotation.y = lerp(
        groupRef.current.rotation.y,
        driftDirection.current * 0.4,
        4 * delta
      );

      const driftLevel = getDriftLevel(driftPower.current);
      if (isDrifting !== isDriftingRef.current) {
        isDriftingRef.current = isDrifting;
        if (isDrifting) {
          sparksLeftRef?.current?.setEmitState(true);
          sparksRightRef?.current?.setEmitState(true);
          glow1Ref?.current?.setOpacity(1);
          glow2Ref?.current?.setOpacity(1);
          skate1Ref?.current?.setOpacity(1);
          skate2Ref?.current?.setOpacity(1);
          
        } else {
          sparksLeftRef?.current?.setEmitState(false);
          sparksRightRef?.current?.setEmitState(false);
          glow1Ref?.current?.setOpacity(0);
          glow2Ref?.current?.setOpacity(0);
          skate1Ref?.current?.setOpacity(0);
          skate2Ref?.current?.setOpacity(0);
        }
      }

      if (isDrifting) {
        glow1Ref?.current?.setColor(driftLevel.color);
        glow2Ref?.current?.setColor(driftLevel.color);
        glow1Ref?.current?.setLevel(driftLevel.threshold);
        glow2Ref?.current?.setLevel(driftLevel.threshold);
    

        sparksLeftRef?.current?.setColor(driftLevel.color);
        sparksRightRef?.current?.setColor(driftLevel.color);
      }
      setDriftLevel(driftLevel);

      setFlamePositions([
        flamePositionLeftRef.current.getWorldPosition(new Vector3()),
        flamePositionRightRef.current.getWorldPosition(new Vector3()),
      ]);
      setBoostPower(driftLevel.threshold / 2);
    }
  });

  useEffect(() => {
    if (glow1Ref.current && glow2Ref.current) {
      glow1Ref?.current?.setOpacity(0);
      glow2Ref?.current?.setOpacity(0);
    }
  }, []);
  return (
    <>
      {/* <pointLight intensity={2000} position={[0, 10, 0]}/> */}
      <KartDust wheelStates={dustWheelStates.current} />
      <group ref={groupRef} dispose={null}>
        <group ref={leftParticles} rotation-y={Math.PI}>
          <Glow ref={glow1Ref} driftDirection={driftDirection} />
          <Sparks ref={sparksLeftRef} left={true} />
          <Trails left={true} />
          <group position={[-.15, 0.2, -0.2]}>
            <Skate ref={skate1Ref} />
          </group>
        </group>
        <group ref={rightParticles} rotation-y={Math.PI}>
          <Glow ref={glow2Ref} driftDirection={driftDirection} />
          <Sparks ref={sparksRightRef} />
          <Trails/>
          <group position={[.15, 0.2, -0.2]}>
            <Skate ref={skate2Ref} />
          </group>
        </group>
        <group
          position={[0.5, -1.1, 1.5]}
          rotation-x={-Math.PI / 9}
          ref={flamePositionLeftRef}
        >
          <VFXEmitter
            ref={smoke1Ref}
            emitter="smoke"
            settings={{
              duration: 0.02,
              delay: 0.1,
              nbParticles: 1,
              spawnMode: "time",
              loop: true,
              startPositionMin: [0, 0, 0],
              startPositionMax: [0, 0, 0],
              startRotationMin: [0, 0, -1],
              startRotationMax: [0, 0, 1],
              particlesLifetime: [0.2, 0.4],
              speed: [2, 2],
              colorStart: "#ffffff",
              colorEnd: "#ffffff",
              directionMin: [0, 0, 0.8],
              directionMax: [0, 0.5, 1],
              rotationSpeedMin: [0, 0, -1],
              rotationSpeedMax: [0, 0, 1],
              size: [0.5, 1],
            }}
          />
        </group>
        <group
          position={[-0.5, -1.1, 1.5]}
          rotation-x={-Math.PI / 9}
          ref={flamePositionRightRef}
        >
          <VFXEmitter
            ref={smoke2Ref}
            emitter="smoke"
            settings={{
              duration: 0.02,
              delay: 0.1,
              nbParticles: 1,
              spawnMode: "time",
              loop: true,
              startPositionMin: [0, 0, 0],
              startPositionMax: [0, 0, 0],
              startRotationMin: [0, 0, -1],
              startRotationMax: [0, 0, 1],
              particlesLifetime: [0.2, 0.4],
              speed: [2, 2],
              colorStart: "#ffffff",
              colorEnd: "#ffffff",
              directionMin: [0, 0, 0.8],
              directionMax: [0, 0.5, 1],
              rotationSpeedMin: [0, 0, -1],
              rotationSpeedMax: [0, 0, 1],
              size: [0.5, 1],
            }}
          />
        </group>
        <group position-y={-0.5} scale={1} rotation-y={Math.PI}>
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.body.geometry}
            material={materials.m_Body}
            ref={bodyRef}
          >
            <mesh
              ref={wheelRef}
              castShadow
              receiveShadow
              geometry={nodes.d_wheel.geometry}
              material={materials.m_Body}
              position={[0, 0.355, 0.542]}
              rotation={[-1.134, 0, 0]}
            />
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.booster.geometry}
              material={materials.m_Body}
              position={[0, 0.25, -0.55]}
              rotation={[0.279, 0, 0]}
            />
          </mesh>

          <mesh
            ref={wheel2}
            castShadow
            receiveShadow
            geometry={nodes.wheel_2.geometry}
            material={materials.m_Tire}
            position={[-0.77, -0.137, -0.7]}
          />
          <mesh
            ref={wheel3}
            castShadow
            receiveShadow
            geometry={nodes.wheel_3.geometry}
            material={materials.m_Tire}
            position={[0.74, -0.137, -0.7]}
          ></mesh>
          <group ref={frontWheels}>
            <mesh
              ref={wheel1}
              castShadow
              receiveShadow
              geometry={nodes.wheel_1.geometry}
              material={materials.m_Tire}
              position={[0.7, -0.2, 0.7]}
            ></mesh>
            <mesh
              ref={wheel0}
              castShadow
              receiveShadow
              geometry={nodes.wheel_0.geometry}
              material={materials.m_Tire}
              position={[-0.7, -0.2, 0.7]}
            />
          </group>

          {/* <mesh castShadow receiveShadow geometry={nodes.shape.geometry} material={materials['default']} /> */}
        </group>
      </group>
    </>
  );
}

useGLTF.preload("/models/kart.glb");
